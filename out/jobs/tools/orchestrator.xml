<flow-definition>
    <actions></actions>
    <description>Batch runner to execute selected jobs sequentially or in parallel. Uses logical IDs from orchestrator/registry.groovy to tolerate renames.</description>
    <keepDependencies>false</keepDependencies>
    <properties>
        <hudson.model.ParametersDefinitionProperty>
            <parameterDefinitions>
                <hudson.model.ChoiceParameterDefinition>
                    <choices class='java.util.Arrays$ArrayList'>
                        <a class='string-array'>
                            <string>sequential</string>
                            <string>parallel</string>
                        </a>
                    </choices>
                    <name>MODE</name>
                    <description>Execution mode for selected jobs</description>
                </hudson.model.ChoiceParameterDefinition>
                <hudson.model.StringParameterDefinition>
                    <name>JOBS</name>
                    <defaultValue></defaultValue>
                    <description>Comma-separated list of logical IDs (from registry.groovy) or full job names. Empty = all registered jobs.</description>
                </hudson.model.StringParameterDefinition>
                <hudson.model.BooleanParameterDefinition>
                    <name>PROPAGATE</name>
                    <defaultValue>true</defaultValue>
                    <description>Fail orchestrator if any job fails</description>
                </hudson.model.BooleanParameterDefinition>
                <hudson.model.BooleanParameterDefinition>
                    <name>DRY_RUN</name>
                    <defaultValue>false</defaultValue>
                    <description>Show what would run without triggering</description>
                </hudson.model.BooleanParameterDefinition>
            </parameterDefinitions>
        </hudson.model.ParametersDefinitionProperty>
    </properties>
    <triggers></triggers>
    <definition class='org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition'>
        <script>// Orchestrator Pipeline: runs selected jobs sequentially or in parallel.
// Parameters provided by Job DSL job definition.

@Library('') _ // no shared libs; standard pipeline only

pipeline {
  agent any
  options { timestamps() }
  stages {
    stage('Checkout') {
      steps {
        // Ensure we have the repo so we can load registry.groovy
        checkout scm
      }
    }
    stage('Resolve Selection') {
      steps {
        script {
          def reg = load 'orchestrator/registry.groovy'
          // parse params.JOBS as comma-separated tokens; allow IDs or full job names
          def tokens = (params.JOBS ?: '').split(',')*.trim().findAll { it }
          if (!tokens) {
            // default: all registry entries
            tokens = reg.keySet() as List
          }
          // map tokens to actual job names
          def resolved = [] as LinkedHashSet
          tokens.each { t -&gt;
            if (reg.containsKey(t)) {
              resolved &lt;&lt; (reg[t].name as String)
            } else {
              // assume token is a full job name
              resolved &lt;&lt; t
            }
          }
          if (!resolved) error('No jobs resolved from selection')
          currentBuild.displayName = "${env.BUILD_NUMBER} · ${params.MODE} · ${resolved.size()} jobs"
          env.ORCH_JOBS_JSON = groovy.json.JsonOutput.toJson(resolved as List)
        }
      }
    }
    stage('Run') {
      steps {
        script {
          def targets = new groovy.json.JsonSlurperClassic().parseText(env.ORCH_JOBS_JSON) as List
          echo "Targets: ${targets}"
          if (params.DRY_RUN) {
            echo 'DRY_RUN=true; skipping execution'
            return
          }
          if (params.MODE == 'parallel') {
            def branches = [:]
            targets.each { name -&gt;
              // capture for closure
              def jobName = name
              branches[jobName] = {
                stage("${jobName}") {
                  build job: jobName, wait: true, propagate: params.PROPAGATE
                }
              }
            }
            parallel branches
          } else {
            targets.each { jobName -&gt;
              stage("${jobName}") {
                build job: jobName, wait: true, propagate: params.PROPAGATE
              }
            }
          }
        }
      }
    }
  }
}

</script>
        <sandbox>true</sandbox>
    </definition>
</flow-definition>
